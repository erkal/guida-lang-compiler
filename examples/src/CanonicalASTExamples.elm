module CanonicalASTExamples exposing (..)


a =
    Module
        (Canonical (Name "elm" "browser") "Browser")
        (Export
            (D
                [ ( "Document", At (Region (Position 4 17) (Position 4 25)) ExportAlias )
                , ( "UrlRequest", At (Region (Position 5 20) (Position 5 30)) ExportUnionOpen )
                , ( "application", At (Region (Position 5 7) (Position 5 18)) ExportValue )
                , ( "document", At (Region (Position 4 7) (Position 4 15)) ExportValue )
                , ( "element", At (Region (Position 3 7) (Position 3 14)) ExportValue )
                , ( "sandbox", At (Region (Position 2 7) (Position 2 14)) ExportValue )
                ]
            )
        )
        (YesDocs
            (Comment
                (Snippet
                    { fptr = "module Browser exposing\n    ( sandbox\n    \n                , element\n    , document, Document\n    , application, UrlRequest(..)\n    )\n\n{-| This module helps you set up an Elm `Program` with functions like\n[`sandbox`](#sandbox) and [`document`](#document).\n\n\n# Sandboxes\n\n@docs sandbox\n\n\n# Elements\n\n@docs element\n\n\n# Documents\n\n@docs document, Document\n\n\n# Applications\n\n@docs application, UrlRequest\n\n-}\n\nimport Browser.Navigation as Navigation\nimport Debugger.Main\nimport Dict\nimport Elm.Kernel.Browser\nimport Html exposing (Html)\nimport Url\n\n\n\n-- SANDBOX\n\n\n{-| Create a “sandboxed” program that cannot communicate with the outside\nworld.\n\nThis is great for learning the basics of [The Elm Architecture][tea]. You can\nsee sandboxes in action in the following examples:\n\n  - [Buttons](https://guide.elm-lang.org/architecture/buttons.html)\n  - [Text Fields](https://guide.elm-lang.org/architecture/text_fields.html)\n  - [Forms](https://guide.elm-lang.org/architecture/forms.html)\n\nThose are nice, but **I very highly recommend reading [this guide][guide]\nstraight through** to really learn how Elm works. Understanding the\nfundamentals actually pays off in this language!\n\n[tea]: https://guide.elm-lang.org/architecture/\n[guide]: https://guide.elm-lang.org/\n\n-}\nsandbox :\n    { init : model\n    , view : model -> Html msg\n    , update : msg -> model -> model\n    }\n    -> Program () model msg\nsandbox impl =\n    Elm.Kernel.Browser.element\n        { init = \\() -> ( impl.init, Cmd.none )\n        , view = impl.view\n        , update = \\msg model -> ( impl.update msg model, Cmd.none )\n        , subscriptions = \\_ -> Sub.none\n        }\n\n\n\n-- ELEMENT\n\n\n{-| Create an HTML element managed by Elm. The resulting elements are easy to\nembed in larger JavaScript projects, and lots of companies that use Elm\nstarted with this approach! Try it out on something small. If it works, great,\ndo more! If not, revert, no big deal.\n\nUnlike a [`sandbox`](#sandbox), an `element` can talk to the outside world in\na couple ways:\n\n  - `Cmd` &mdash; you can “command” the Elm runtime to do stuff, like HTTP.\n  - `Sub` &mdash; you can “subscribe” to event sources, like clock ticks.\n  - `flags` &mdash; JavaScript can pass in data when starting the Elm program\n  - `ports` &mdash; set up a client-server relationship with JavaScript\n\nAs you read [the guide][guide] you will run into a bunch of examples of `element`\nin [this section][fx]. You can learn more about flags and ports in [the interop\nsection][interop].\n\n[guide]: https://guide.elm-lang.org/\n[fx]: https://guide.elm-lang.org/effects/\n[interop]: https://guide.elm-lang.org/interop/\n\n-}\nelement :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Html msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\nelement =\n    Elm.Kernel.Browser.element\n\n\n\n-- DOCUMENT\n\n\n{-| Create an HTML document managed by Elm. This expands upon what `element`\ncan do in that `view` now gives you control over the `<title>` and `<body>`.\n-}\ndocument :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\ndocument =\n    Elm.Kernel.Browser.document\n\n\n{-| This data specifies the `<title>` and all of the nodes that should go in\nthe `<body>`. This means you can update the title as your application changes.\nMaybe your \"single-page app\" navigates to a \"different page\", maybe a calendar\napp shows an accurate date in the title, etc.\n\n> **Note about CSS:** This looks similar to an `<html>` document, but this is\n> not the place to manage CSS assets. If you want to work with CSS, there are\n> a couple ways:\n>\n> 1.  Packages like [`rtfeldman/elm-css`][elm-css] give all of the features\n>     of CSS without any CSS files. You can add all the styles you need in your\n>     `view` function, and there is no need to worry about class names matching.\n>\n> 2.  Compile your Elm code to JavaScript with `elm make --output=elm.js` and\n>     then make your own HTML file that loads `elm.js` and the CSS file you want.\n>     With this approach, it does not matter where the CSS comes from. Write it\n>     by hand. Generate it. Whatever you want to do.\n>\n> 3.  If you need to change `<link>` tags dynamically, you can send messages\n>     out a port to do it in JavaScript.\n>\n> The bigger point here is that loading assets involves touching the `<head>`\n> as an implementation detail of browsers, but that does not mean it should be\n> the responsibility of the `view` function in Elm. So we do it differently!\n\n[elm-css]: /packages/rtfeldman/elm-css/latest/\n\n-}\ntype alias Document msg =\n    { title : String\n    , body : List (Html msg)\n    }\n\n\n\n-- APPLICATION\n\n\n{-| Create an application that manages [`Url`][url] changes.\n\n**When the application starts**, `init` gets the initial `Url`. You can show\ndifferent things depending on the `Url`!\n\n**When someone clicks a link**, like `<a href=\"/home\">Home</a>`, it always goes\nthrough `onUrlRequest`. The resulting message goes to your `update` function,\ngiving you a chance to save scroll position or persist data before changing\nthe URL yourself with [`pushUrl`][bnp] or [`load`][bnl]. More info on this in\nthe [`UrlRequest`](#UrlRequest) docs!\n\n**When the URL changes**, the new `Url` goes through `onUrlChange`. The\nresulting message goes to `update` where you can decide what to show next.\n\nApplications always use the [`Browser.Navigation`][bn] module for precise\ncontrol over `Url` changes.\n\n**More Info:** Here are some example usages of `application` programs:\n\n  - [RealWorld example app](https://github.com/rtfeldman/elm-spa-example)\n  - [Elm’s package website](https://github.com/elm/package.elm-lang.org)\n\nThese are quite advanced Elm programs, so be sure to go through [the guide][g]\nfirst to get a solid conceptual foundation before diving in! If you start\nreading a calculus book from page 314, it might seem confusing. Same here!\n\n**Note:** Can an [`element`](#element) manage the URL too? Read [this]!\n\n[g]: https://guide.elm-lang.org/\n[bn]: Browser-Navigation\n[bnp]: Browser-Navigation#pushUrl\n[bnl]: Browser-Navigation#load\n[url]: /packages/elm/url/latest/Url#Url\n[this]: https://github.com/elm/browser/blob/1.0.2/notes/navigation-in-elements.md\n\n-}\napplication :\n    { init : flags -> Url.Url -> Navigation.Key -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    , onUrlRequest : UrlRequest -> msg\n    , onUrlChange : Url.Url -> msg\n    }\n    -> Program flags model msg\napplication =\n    Elm.Kernel.Browser.application\n\n\n{-| All links in an [`application`](#application) create a `UrlRequest`. So\nwhen you click `<a href=\"/home\">Home</a>`, it does not just navigate! It\nnotifies `onUrlRequest` that the user wants to change the `Url`.\n\n\n### `Internal` vs `External`\n\nImagine we are browsing `https://example.com`. An `Internal` link would be\nlike:\n\n  - `settings#privacy`\n  - `/home`\n  - `https://example.com/home`\n  - `//example.com/home`\n\nAll of these links exist under the `https://example.com` domain. An `External`\nlink would be like:\n\n  - `https://elm-lang.org/examples`\n  - `https://other.example.com/home`\n  - `http://example.com/home`\n\nAnything that changes the domain. Notice that changing the protocol from\n`https` to `http` is considered a different domain! (And vice versa!)\n\n\n### Purpose\n\nHaving a `UrlRequest` requires a case in your `update` like this:\n\n    import Browser exposing (..)\n    import Browser.Navigation as Nav\n    import Url\n\n    type Msg\n        = ClickedLink UrlRequest\n\n    update : Msg -> Model -> ( Model, Cmd msg )\n    update msg model =\n        case msg of\n            ClickedLink urlRequest ->\n                case urlRequest of\n                    Internal url ->\n                        ( model\n                        , Nav.pushUrl model.key (Url.toString url)\n                        )\n\n                    External url ->\n                        ( model\n                        , Nav.load url\n                        )\n\nThis is useful because it gives you a chance to customize the behavior in each\ncase. Maybe on some `Internal` links you save the scroll position with\n[`Browser.Dom.getViewport`](Browser-Dom#getViewport) so you can restore it\nlater. Maybe on `External` links you persist parts of the `Model` on your\nservers before leaving. Whatever you need to do!\n\n**Note:** Knowing the scroll position is not enough to restore it! What if the\nbrowser dimensions change? The scroll position will not correlate with\n&ldquo;what was on screen&rdquo; anymore. So it may be better to remember\n&ldquo;what was on screen&rdquo; and recreate the position based on that. For\nexample, in a Wikipedia article, remember the header that they were looking at\nmost recently. [`Browser.Dom.getElement`](Browser-Dom#getElement) is designed\nfor figuring that out!\n\n-}\ntype UrlRequest\n    = Internal Url.Url\n    | External String\n"
                    , length = 264
                    , offCol = 4
                    , offRow = 8
                    , offset = 121
                    }
                )
            )
            [ ( "UrlRequest"
              , Comment
                    (Snippet
                        { fptr = "module Browser exposing\n    ( sandbox\n    , element\n    , document, Document\n    , application, UrlRequest(..)\n    )\n\n{-| This module helps you set up an Elm `Program` with functions like\n[`sandbox`](#sandbox) and [`document`](#document).\n\n\n# Sandboxes\n\n@docs sandbox\n\n\n# Elements\n\n@docs element\n\n\n# Documents\n\n@docs document, Document\n\n\n# Applications\n\n@docs application, UrlRequest\n\n-}\n\nimport Browser.Navigation as Navigation\nimport Debugger.Main\nimport Dict\nimport Elm.Kernel.Browser\nimport Html exposing (Html)\nimport Url\n\n\n\n-- SANDBOX\n\n\n{-| Create a “sandboxed” program that cannot communicate with the outside\nworld.\n\nThis is great for learning the basics of [The Elm Architecture][tea]. You can\nsee sandboxes in action in the following examples:\n\n  - [Buttons](https://guide.elm-lang.org/architecture/buttons.html)\n  - [Text Fields](https://guide.elm-lang.org/architecture/text_fields.html)\n  - [Forms](https://guide.elm-lang.org/architecture/forms.html)\n\nThose are nice, but **I very highly recommend reading [this guide][guide]\nstraight through** to really learn how Elm works. Understanding the\nfundamentals actually pays off in this language!\n\n[tea]: https://guide.elm-lang.org/architecture/\n[guide]: https://guide.elm-lang.org/\n\n-}\nsandbox :\n    { init : model\n    , view : model -> Html msg\n    , update : msg -> model -> model\n    }\n    -> Program () model msg\nsandbox impl =\n    Elm.Kernel.Browser.element\n        { init = \\() -> ( impl.init, Cmd.none )\n        , view = impl.view\n        , update = \\msg model -> ( impl.update msg model, Cmd.none )\n        , subscriptions = \\_ -> Sub.none\n        }\n\n\n\n-- ELEMENT\n\n\n{-| Create an HTML element managed by Elm. The resulting elements are easy to\nembed in larger JavaScript projects, and lots of companies that use Elm\nstarted with this approach! Try it out on something small. If it works, great,\ndo more! If not, revert, no big deal.\n\nUnlike a [`sandbox`](#sandbox), an `element` can talk to the outside world in\na couple ways:\n\n  - `Cmd` &mdash; you can “command” the Elm runtime to do stuff, like HTTP.\n  - `Sub` &mdash; you can “subscribe” to event sources, like clock ticks.\n  - `flags` &mdash; JavaScript can pass in data when starting the Elm program\n  - `ports` &mdash; set up a client-server relationship with JavaScript\n\nAs you read [the guide][guide] you will run into a bunch of examples of `element`\nin [this section][fx]. You can learn more about flags and ports in [the interop\nsection][interop].\n\n[guide]: https://guide.elm-lang.org/\n[fx]: https://guide.elm-lang.org/effects/\n[interop]: https://guide.elm-lang.org/interop/\n\n-}\nelement :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Html msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\nelement =\n    Elm.Kernel.Browser.element\n\n\n\n-- DOCUMENT\n\n\n{-| Create an HTML document managed by Elm. This expands upon what `element`\ncan do in that `view` now gives you control over the `<title>` and `<body>`.\n-}\ndocument :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\ndocument =\n    Elm.Kernel.Browser.document\n\n\n{-| This data specifies the `<title>` and all of the nodes that should go in\nthe `<body>`. This means you can update the title as your application changes.\nMaybe your \"single-page app\" navigates to a \"different page\", maybe a calendar\napp shows an accurate date in the title, etc.\n\n> **Note about CSS:** This looks similar to an `<html>` document, but this is\n> not the place to manage CSS assets. If you want to work with CSS, there are\n> a couple ways:\n>\n> 1.  Packages like [`rtfeldman/elm-css`][elm-css] give all of the features\n>     of CSS without any CSS files. You can add all the styles you need in your\n>     `view` function, and there is no need to worry about class names matching.\n>\n> 2.  Compile your Elm code to JavaScript with `elm make --output=elm.js` and\n>     then make your own HTML file that loads `elm.js` and the CSS file you want.\n>     With this approach, it does not matter where the CSS comes from. Write it\n>     by hand. Generate it. Whatever you want to do.\n>\n> 3.  If you need to change `<link>` tags dynamically, you can send messages\n>     out a port to do it in JavaScript.\n>\n> The bigger point here is that loading assets involves touching the `<head>`\n> as an implementation detail of browsers, but that does not mean it should be\n> the responsibility of the `view` function in Elm. So we do it differently!\n\n[elm-css]: /packages/rtfeldman/elm-css/latest/\n\n-}\ntype alias Document msg =\n    { title : String\n    , body : List (Html msg)\n    }\n\n\n\n-- APPLICATION\n\n\n{-| Create an application that manages [`Url`][url] changes.\n\n**When the application starts**, `init` gets the initial `Url`. You can show\ndifferent things depending on the `Url`!\n\n**When someone clicks a link**, like `<a href=\"/home\">Home</a>`, it always goes\nthrough `onUrlRequest`. The resulting message goes to your `update` function,\ngiving you a chance to save scroll position or persist data before changing\nthe URL yourself with [`pushUrl`][bnp] or [`load`][bnl]. More info on this in\nthe [`UrlRequest`](#UrlRequest) docs!\n\n**When the URL changes**, the new `Url` goes through `onUrlChange`. The\nresulting message goes to `update` where you can decide what to show next.\n\nApplications always use the [`Browser.Navigation`][bn] module for precise\ncontrol over `Url` changes.\n\n**More Info:** Here are some example usages of `application` programs:\n\n  - [RealWorld example app](https://github.com/rtfeldman/elm-spa-example)\n  - [Elm’s package website](https://github.com/elm/package.elm-lang.org)\n\nThese are quite advanced Elm programs, so be sure to go through [the guide][g]\nfirst to get a solid conceptual foundation before diving in! If you start\nreading a calculus book from page 314, it might seem confusing. Same here!\n\n**Note:** Can an [`element`](#element) manage the URL too? Read [this]!\n\n[g]: https://guide.elm-lang.org/\n[bn]: Browser-Navigation\n[bnp]: Browser-Navigation#pushUrl\n[bnl]: Browser-Navigation#load\n[url]: /packages/elm/url/latest/Url#Url\n[this]: https://github.com/elm/browser/blob/1.0.2/notes/navigation-in-elements.md\n\n-}\napplication :\n    { init : flags -> Url.Url -> Navigation.Key -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    , onUrlRequest : UrlRequest -> msg\n    , onUrlChange : Url.Url -> msg\n    }\n    -> Program flags model msg\napplication =\n    Elm.Kernel.Browser.application\n\n\n{-| All links in an [`application`](#application) create a `UrlRequest`. So\nwhen you click `<a href=\"/home\">Home</a>`, it does not just navigate! It\nnotifies `onUrlRequest` that the user wants to change the `Url`.\n\n\n### `Internal` vs `External`\n\nImagine we are browsing `https://example.com`. An `Internal` link would be\nlike:\n\n  - `settings#privacy`\n  - `/home`\n  - `https://example.com/home`\n  - `//example.com/home`\n\nAll of these links exist under the `https://example.com` domain. An `External`\nlink would be like:\n\n  - `https://elm-lang.org/examples`\n  - `https://other.example.com/home`\n  - `http://example.com/home`\n\nAnything that changes the domain. Notice that changing the protocol from\n`https` to `http` is considered a different domain! (And vice versa!)\n\n\n### Purpose\n\nHaving a `UrlRequest` requires a case in your `update` like this:\n\n    import Browser exposing (..)\n    import Browser.Navigation as Nav\n    import Url\n\n    type Msg\n        = ClickedLink UrlRequest\n\n    update : Msg -> Model -> ( Model, Cmd msg )\n    update msg model =\n        case msg of\n            ClickedLink urlRequest ->\n                case urlRequest of\n                    Internal url ->\n                        ( model\n                        , Nav.pushUrl model.key (Url.toString url)\n                        )\n\n                    External url ->\n                        ( model\n                        , Nav.load url\n                        )\n\nThis is useful because it gives you a chance to customize the behavior in each\ncase. Maybe on some `Internal` links you save the scroll position with\n[`Browser.Dom.getViewport`](Browser-Dom#getViewport) so you can restore it\nlater. Maybe on `External` links you persist parts of the `Model` on your\nservers before leaving. Whatever you need to do!\n\n**Note:** Knowing the scroll position is not enough to restore it! What if the\nbrowser dimensions change? The scroll position will not correlate with\n&ldquo;what was on screen&rdquo; anymore. So it may be better to remember\n&ldquo;what was on screen&rdquo; and recreate the position based on that. For\nexample, in a Wikipedia article, remember the header that they were looking at\nmost recently. [`Browser.Dom.getElement`](Browser-Dom#getElement) is designed\nfor figuring that out!\n\n-}\ntype UrlRequest\n    = Internal Url.Url\n    | External String\n"
                        , length = 2271
                        , offCol = 4
                        , offRow = 220
                        , offset = 6715
                        }
                    )
              )
            , ( "application", Comment (Snippet { fptr = "module Browser exposing\n    ( sandbox\n    , element\n    , document, Document\n    , application, UrlRequest(..)\n    )\n\n{-| This module helps you set up an Elm `Program` with functions like\n[`sandbox`](#sandbox) and [`document`](#document).\n\n\n# Sandboxes\n\n@docs sandbox\n\n\n# Elements\n\n@docs element\n\n\n# Documents\n\n@docs document, Document\n\n\n# Applications\n\n@docs application, UrlRequest\n\n-}\n\nimport Browser.Navigation as Navigation\nimport Debugger.Main\nimport Dict\nimport Elm.Kernel.Browser\nimport Html exposing (Html)\nimport Url\n\n\n\n-- SANDBOX\n\n\n{-| Create a “sandboxed” program that cannot communicate with the outside\nworld.\n\nThis is great for learning the basics of [The Elm Architecture][tea]. You can\nsee sandboxes in action in the following examples:\n\n  - [Buttons](https://guide.elm-lang.org/architecture/buttons.html)\n  - [Text Fields](https://guide.elm-lang.org/architecture/text_fields.html)\n  - [Forms](https://guide.elm-lang.org/architecture/forms.html)\n\nThose are nice, but **I very highly recommend reading [this guide][guide]\nstraight through** to really learn how Elm works. Understanding the\nfundamentals actually pays off in this language!\n\n[tea]: https://guide.elm-lang.org/architecture/\n[guide]: https://guide.elm-lang.org/\n\n-}\nsandbox :\n    { init : model\n    , view : model -> Html msg\n    , update : msg -> model -> model\n    }\n    -> Program () model msg\nsandbox impl =\n    Elm.Kernel.Browser.element\n        { init = \\() -> ( impl.init, Cmd.none )\n        , view = impl.view\n        , update = \\msg model -> ( impl.update msg model, Cmd.none )\n        , subscriptions = \\_ -> Sub.none\n        }\n\n\n\n-- ELEMENT\n\n\n{-| Create an HTML element managed by Elm. The resulting elements are easy to\nembed in larger JavaScript projects, and lots of companies that use Elm\nstarted with this approach! Try it out on something small. If it works, great,\ndo more! If not, revert, no big deal.\n\nUnlike a [`sandbox`](#sandbox), an `element` can talk to the outside world in\na couple ways:\n\n  - `Cmd` &mdash; you can “command” the Elm runtime to do stuff, like HTTP.\n  - `Sub` &mdash; you can “subscribe” to event sources, like clock ticks.\n  - `flags` &mdash; JavaScript can pass in data when starting the Elm program\n  - `ports` &mdash; set up a client-server relationship with JavaScript\n\nAs you read [the guide][guide] you will run into a bunch of examples of `element`\nin [this section][fx]. You can learn more about flags and ports in [the interop\nsection][interop].\n\n[guide]: https://guide.elm-lang.org/\n[fx]: https://guide.elm-lang.org/effects/\n[interop]: https://guide.elm-lang.org/interop/\n\n-}\nelement :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Html msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\nelement =\n    Elm.Kernel.Browser.element\n\n\n\n-- DOCUMENT\n\n\n{-| Create an HTML document managed by Elm. This expands upon what `element`\ncan do in that `view` now gives you control over the `<title>` and `<body>`.\n-}\ndocument :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\ndocument =\n    Elm.Kernel.Browser.document\n\n\n{-| This data specifies the `<title>` and all of the nodes that should go in\nthe `<body>`. This means you can update the title as your application changes.\nMaybe your \"single-page app\" navigates to a \"different page\", maybe a calendar\napp shows an accurate date in the title, etc.\n\n> **Note about CSS:** This looks similar to an `<html>` document, but this is\n> not the place to manage CSS assets. If you want to work with CSS, there are\n> a couple ways:\n>\n> 1.  Packages like [`rtfeldman/elm-css`][elm-css] give all of the features\n>     of CSS without any CSS files. You can add all the styles you need in your\n>     `view` function, and there is no need to worry about class names matching.\n>\n> 2.  Compile your Elm code to JavaScript with `elm make --output=elm.js` and\n>     then make your own HTML file that loads `elm.js` and the CSS file you want.\n>     With this approach, it does not matter where the CSS comes from. Write it\n>     by hand. Generate it. Whatever you want to do.\n>\n> 3.  If you need to change `<link>` tags dynamically, you can send messages\n>     out a port to do it in JavaScript.\n>\n> The bigger point here is that loading assets involves touching the `<head>`\n> as an implementation detail of browsers, but that does not mean it should be\n> the responsibility of the `view` function in Elm. So we do it differently!\n\n[elm-css]: /packages/rtfeldman/elm-css/latest/\n\n-}\ntype alias Document msg =\n    { title : String\n    , body : List (Html msg)\n    }\n\n\n\n-- APPLICATION\n\n\n{-| Create an application that manages [`Url`][url] changes.\n\n**When the application starts**, `init` gets the initial `Url`. You can show\ndifferent things depending on the `Url`!\n\n**When someone clicks a link**, like `<a href=\"/home\">Home</a>`, it always goes\nthrough `onUrlRequest`. The resulting message goes to your `update` function,\ngiving you a chance to save scroll position or persist data before changing\nthe URL yourself with [`pushUrl`][bnp] or [`load`][bnl]. More info on this in\nthe [`UrlRequest`](#UrlRequest) docs!\n\n**When the URL changes**, the new `Url` goes through `onUrlChange`. The\nresulting message goes to `update` where you can decide what to show next.\n\nApplications always use the [`Browser.Navigation`][bn] module for precise\ncontrol over `Url` changes.\n\n**More Info:** Here are some example usages of `application` programs:\n\n  - [RealWorld example app](https://github.com/rtfeldman/elm-spa-example)\n  - [Elm’s package website](https://github.com/elm/package.elm-lang.org)\n\nThese are quite advanced Elm programs, so be sure to go through [the guide][g]\nfirst to get a solid conceptual foundation before diving in! If you start\nreading a calculus book from page 314, it might seem confusing. Same here!\n\n**Note:** Can an [`element`](#element) manage the URL too? Read [this]!\n\n[g]: https://guide.elm-lang.org/\n[bn]: Browser-Navigation\n[bnp]: Browser-Navigation#pushUrl\n[bnl]: Browser-Navigation#load\n[url]: /packages/elm/url/latest/Url#Url\n[this]: https://github.com/elm/browser/blob/1.0.2/notes/navigation-in-elements.md\n\n-}\napplication :\n    { init : flags -> Url.Url -> Navigation.Key -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    , onUrlRequest : UrlRequest -> msg\n    , onUrlChange : Url.Url -> msg\n    }\n    -> Program flags model msg\napplication =\n    Elm.Kernel.Browser.application\n\n\n{-| All links in an [`application`](#application) create a `UrlRequest`. So\nwhen you click `<a href=\"/home\">Home</a>`, it does not just navigate! It\nnotifies `onUrlRequest` that the user wants to change the `Url`.\n\n\n### `Internal` vs `External`\n\nImagine we are browsing `https://example.com`. An `Internal` link would be\nlike:\n\n  - `settings#privacy`\n  - `/home`\n  - `https://example.com/home`\n  - `//example.com/home`\n\nAll of these links exist under the `https://example.com` domain. An `External`\nlink would be like:\n\n  - `https://elm-lang.org/examples`\n  - `https://other.example.com/home`\n  - `http://example.com/home`\n\nAnything that changes the domain. Notice that changing the protocol from\n`https` to `http` is considered a different domain! (And vice versa!)\n\n\n### Purpose\n\nHaving a `UrlRequest` requires a case in your `update` like this:\n\n    import Browser exposing (..)\n    import Browser.Navigation as Nav\n    import Url\n\n    type Msg\n        = ClickedLink UrlRequest\n\n    update : Msg -> Model -> ( Model, Cmd msg )\n    update msg model =\n        case msg of\n            ClickedLink urlRequest ->\n                case urlRequest of\n                    Internal url ->\n                        ( model\n                        , Nav.pushUrl model.key (Url.toString url)\n                        )\n\n                    External url ->\n                        ( model\n                        , Nav.load url\n                        )\n\nThis is useful because it gives you a chance to customize the behavior in each\ncase. Maybe on some `Internal` links you save the scroll position with\n[`Browser.Dom.getViewport`](Browser-Dom#getViewport) so you can restore it\nlater. Maybe on `External` links you persist parts of the `Model` on your\nservers before leaving. Whatever you need to do!\n\n**Note:** Knowing the scroll position is not enough to restore it! What if the\nbrowser dimensions change? The scroll position will not correlate with\n&ldquo;what was on screen&rdquo; anymore. So it may be better to remember\n&ldquo;what was on screen&rdquo; and recreate the position based on that. For\nexample, in a Wikipedia article, remember the header that they were looking at\nmost recently. [`Browser.Dom.getElement`](Browser-Dom#getElement) is designed\nfor figuring that out!\n\n-}\ntype UrlRequest\n    = Internal Url.Url\n    | External String\n", length = 1548, offCol = 4, offRow = 171, offset = 4791 }) )
            , ( "Document", Comment (Snippet { fptr = "module Browser exposing\n    ( sandbox\n    , element\n    , document, Document\n    , application, UrlRequest(..)\n    )\n\n{-| This module helps you set up an Elm `Program` with functions like\n[`sandbox`](#sandbox) and [`document`](#document).\n\n\n# Sandboxes\n\n@docs sandbox\n\n\n# Elements\n\n@docs element\n\n\n# Documents\n\n@docs document, Document\n\n\n# Applications\n\n@docs application, UrlRequest\n\n-}\n\nimport Browser.Navigation as Navigation\nimport Debugger.Main\nimport Dict\nimport Elm.Kernel.Browser\nimport Html exposing (Html)\nimport Url\n\n\n\n-- SANDBOX\n\n\n{-| Create a “sandboxed” program that cannot communicate with the outside\nworld.\n\nThis is great for learning the basics of [The Elm Architecture][tea]. You can\nsee sandboxes in action in the following examples:\n\n  - [Buttons](https://guide.elm-lang.org/architecture/buttons.html)\n  - [Text Fields](https://guide.elm-lang.org/architecture/text_fields.html)\n  - [Forms](https://guide.elm-lang.org/architecture/forms.html)\n\nThose are nice, but **I very highly recommend reading [this guide][guide]\nstraight through** to really learn how Elm works. Understanding the\nfundamentals actually pays off in this language!\n\n[tea]: https://guide.elm-lang.org/architecture/\n[guide]: https://guide.elm-lang.org/\n\n-}\nsandbox :\n    { init : model\n    , view : model -> Html msg\n    , update : msg -> model -> model\n    }\n    -> Program () model msg\nsandbox impl =\n    Elm.Kernel.Browser.element\n        { init = \\() -> ( impl.init, Cmd.none )\n        , view = impl.view\n        , update = \\msg model -> ( impl.update msg model, Cmd.none )\n        , subscriptions = \\_ -> Sub.none\n        }\n\n\n\n-- ELEMENT\n\n\n{-| Create an HTML element managed by Elm. The resulting elements are easy to\nembed in larger JavaScript projects, and lots of companies that use Elm\nstarted with this approach! Try it out on something small. If it works, great,\ndo more! If not, revert, no big deal.\n\nUnlike a [`sandbox`](#sandbox), an `element` can talk to the outside world in\na couple ways:\n\n  - `Cmd` &mdash; you can “command” the Elm runtime to do stuff, like HTTP.\n  - `Sub` &mdash; you can “subscribe” to event sources, like clock ticks.\n  - `flags` &mdash; JavaScript can pass in data when starting the Elm program\n  - `ports` &mdash; set up a client-server relationship with JavaScript\n\nAs you read [the guide][guide] you will run into a bunch of examples of `element`\nin [this section][fx]. You can learn more about flags and ports in [the interop\nsection][interop].\n\n[guide]: https://guide.elm-lang.org/\n[fx]: https://guide.elm-lang.org/effects/\n[interop]: https://guide.elm-lang.org/interop/\n\n-}\nelement :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Html msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\nelement =\n    Elm.Kernel.Browser.element\n\n\n\n-- DOCUMENT\n\n\n{-| Create an HTML document managed by Elm. This expands upon what `element`\ncan do in that `view` now gives you control over the `<title>` and `<body>`.\n-}\ndocument :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\ndocument =\n    Elm.Kernel.Browser.document\n\n\n{-| This data specifies the `<title>` and all of the nodes that should go in\nthe `<body>`. This means you can update the title as your application changes.\nMaybe your \"single-page app\" navigates to a \"different page\", maybe a calendar\napp shows an accurate date in the title, etc.\n\n> **Note about CSS:** This looks similar to an `<html>` document, but this is\n> not the place to manage CSS assets. If you want to work with CSS, there are\n> a couple ways:\n>\n> 1.  Packages like [`rtfeldman/elm-css`][elm-css] give all of the features\n>     of CSS without any CSS files. You can add all the styles you need in your\n>     `view` function, and there is no need to worry about class names matching.\n>\n> 2.  Compile your Elm code to JavaScript with `elm make --output=elm.js` and\n>     then make your own HTML file that loads `elm.js` and the CSS file you want.\n>     With this approach, it does not matter where the CSS comes from. Write it\n>     by hand. Generate it. Whatever you want to do.\n>\n> 3.  If you need to change `<link>` tags dynamically, you can send messages\n>     out a port to do it in JavaScript.\n>\n> The bigger point here is that loading assets involves touching the `<head>`\n> as an implementation detail of browsers, but that does not mean it should be\n> the responsibility of the `view` function in Elm. So we do it differently!\n\n[elm-css]: /packages/rtfeldman/elm-css/latest/\n\n-}\ntype alias Document msg =\n    { title : String\n    , body : List (Html msg)\n    }\n\n\n\n-- APPLICATION\n\n\n{-| Create an application that manages [`Url`][url] changes.\n\n**When the application starts**, `init` gets the initial `Url`. You can show\ndifferent things depending on the `Url`!\n\n**When someone clicks a link**, like `<a href=\"/home\">Home</a>`, it always goes\nthrough `onUrlRequest`. The resulting message goes to your `update` function,\ngiving you a chance to save scroll position or persist data before changing\nthe URL yourself with [`pushUrl`][bnp] or [`load`][bnl]. More info on this in\nthe [`UrlRequest`](#UrlRequest) docs!\n\n**When the URL changes**, the new `Url` goes through `onUrlChange`. The\nresulting message goes to `update` where you can decide what to show next.\n\nApplications always use the [`Browser.Navigation`][bn] module for precise\ncontrol over `Url` changes.\n\n**More Info:** Here are some example usages of `application` programs:\n\n  - [RealWorld example app](https://github.com/rtfeldman/elm-spa-example)\n  - [Elm’s package website](https://github.com/elm/package.elm-lang.org)\n\nThese are quite advanced Elm programs, so be sure to go through [the guide][g]\nfirst to get a solid conceptual foundation before diving in! If you start\nreading a calculus book from page 314, it might seem confusing. Same here!\n\n**Note:** Can an [`element`](#element) manage the URL too? Read [this]!\n\n[g]: https://guide.elm-lang.org/\n[bn]: Browser-Navigation\n[bnp]: Browser-Navigation#pushUrl\n[bnl]: Browser-Navigation#load\n[url]: /packages/elm/url/latest/Url#Url\n[this]: https://github.com/elm/browser/blob/1.0.2/notes/navigation-in-elements.md\n\n-}\napplication :\n    { init : flags -> Url.Url -> Navigation.Key -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    , onUrlRequest : UrlRequest -> msg\n    , onUrlChange : Url.Url -> msg\n    }\n    -> Program flags model msg\napplication =\n    Elm.Kernel.Browser.application\n\n\n{-| All links in an [`application`](#application) create a `UrlRequest`. So\nwhen you click `<a href=\"/home\">Home</a>`, it does not just navigate! It\nnotifies `onUrlRequest` that the user wants to change the `Url`.\n\n\n### `Internal` vs `External`\n\nImagine we are browsing `https://example.com`. An `Internal` link would be\nlike:\n\n  - `settings#privacy`\n  - `/home`\n  - `https://example.com/home`\n  - `//example.com/home`\n\nAll of these links exist under the `https://example.com` domain. An `External`\nlink would be like:\n\n  - `https://elm-lang.org/examples`\n  - `https://other.example.com/home`\n  - `http://example.com/home`\n\nAnything that changes the domain. Notice that changing the protocol from\n`https` to `http` is considered a different domain! (And vice versa!)\n\n\n### Purpose\n\nHaving a `UrlRequest` requires a case in your `update` like this:\n\n    import Browser exposing (..)\n    import Browser.Navigation as Nav\n    import Url\n\n    type Msg\n        = ClickedLink UrlRequest\n\n    update : Msg -> Model -> ( Model, Cmd msg )\n    update msg model =\n        case msg of\n            ClickedLink urlRequest ->\n                case urlRequest of\n                    Internal url ->\n                        ( model\n                        , Nav.pushUrl model.key (Url.toString url)\n                        )\n\n                    External url ->\n                        ( model\n                        , Nav.load url\n                        )\n\nThis is useful because it gives you a chance to customize the behavior in each\ncase. Maybe on some `Internal` links you save the scroll position with\n[`Browser.Dom.getViewport`](Browser-Dom#getViewport) so you can restore it\nlater. Maybe on `External` links you persist parts of the `Model` on your\nservers before leaving. Whatever you need to do!\n\n**Note:** Knowing the scroll position is not enough to restore it! What if the\nbrowser dimensions change? The scroll position will not correlate with\n&ldquo;what was on screen&rdquo; anymore. So it may be better to remember\n&ldquo;what was on screen&rdquo; and recreate the position based on that. For\nexample, in a Wikipedia article, remember the header that they were looking at\nmost recently. [`Browser.Dom.getElement`](Browser-Dom#getElement) is designed\nfor figuring that out!\n\n-}\ntype UrlRequest\n    = Internal Url.Url\n    | External String\n", length = 1391, offCol = 4, offRow = 133, offset = 3292 }) )
            , ( "document", Comment (Snippet { fptr = "module Browser exposing\n    ( sandbox\n    , element\n    , document, Document\n    , application, UrlRequest(..)\n    )\n\n{-| This module helps you set up an Elm `Program` with functions like\n[`sandbox`](#sandbox) and [`document`](#document).\n\n\n# Sandboxes\n\n@docs sandbox\n\n\n# Elements\n\n@docs element\n\n\n# Documents\n\n@docs document, Document\n\n\n# Applications\n\n@docs application, UrlRequest\n\n-}\n\nimport Browser.Navigation as Navigation\nimport Debugger.Main\nimport Dict\nimport Elm.Kernel.Browser\nimport Html exposing (Html)\nimport Url\n\n\n\n-- SANDBOX\n\n\n{-| Create a “sandboxed” program that cannot communicate with the outside\nworld.\n\nThis is great for learning the basics of [The Elm Architecture][tea]. You can\nsee sandboxes in action in the following examples:\n\n  - [Buttons](https://guide.elm-lang.org/architecture/buttons.html)\n  - [Text Fields](https://guide.elm-lang.org/architecture/text_fields.html)\n  - [Forms](https://guide.elm-lang.org/architecture/forms.html)\n\nThose are nice, but **I very highly recommend reading [this guide][guide]\nstraight through** to really learn how Elm works. Understanding the\nfundamentals actually pays off in this language!\n\n[tea]: https://guide.elm-lang.org/architecture/\n[guide]: https://guide.elm-lang.org/\n\n-}\nsandbox :\n    { init : model\n    , view : model -> Html msg\n    , update : msg -> model -> model\n    }\n    -> Program () model msg\nsandbox impl =\n    Elm.Kernel.Browser.element\n        { init = \\() -> ( impl.init, Cmd.none )\n        , view = impl.view\n        , update = \\msg model -> ( impl.update msg model, Cmd.none )\n        , subscriptions = \\_ -> Sub.none\n        }\n\n\n\n-- ELEMENT\n\n\n{-| Create an HTML element managed by Elm. The resulting elements are easy to\nembed in larger JavaScript projects, and lots of companies that use Elm\nstarted with this approach! Try it out on something small. If it works, great,\ndo more! If not, revert, no big deal.\n\nUnlike a [`sandbox`](#sandbox), an `element` can talk to the outside world in\na couple ways:\n\n  - `Cmd` &mdash; you can “command” the Elm runtime to do stuff, like HTTP.\n  - `Sub` &mdash; you can “subscribe” to event sources, like clock ticks.\n  - `flags` &mdash; JavaScript can pass in data when starting the Elm program\n  - `ports` &mdash; set up a client-server relationship with JavaScript\n\nAs you read [the guide][guide] you will run into a bunch of examples of `element`\nin [this section][fx]. You can learn more about flags and ports in [the interop\nsection][interop].\n\n[guide]: https://guide.elm-lang.org/\n[fx]: https://guide.elm-lang.org/effects/\n[interop]: https://guide.elm-lang.org/interop/\n\n-}\nelement :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Html msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\nelement =\n    Elm.Kernel.Browser.element\n\n\n\n-- DOCUMENT\n\n\n{-| Create an HTML document managed by Elm. This expands upon what `element`\ncan do in that `view` now gives you control over the `<title>` and `<body>`.\n-}\ndocument :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\ndocument =\n    Elm.Kernel.Browser.document\n\n\n{-| This data specifies the `<title>` and all of the nodes that should go in\nthe `<body>`. This means you can update the title as your application changes.\nMaybe your \"single-page app\" navigates to a \"different page\", maybe a calendar\napp shows an accurate date in the title, etc.\n\n> **Note about CSS:** This looks similar to an `<html>` document, but this is\n> not the place to manage CSS assets. If you want to work with CSS, there are\n> a couple ways:\n>\n> 1.  Packages like [`rtfeldman/elm-css`][elm-css] give all of the features\n>     of CSS without any CSS files. You can add all the styles you need in your\n>     `view` function, and there is no need to worry about class names matching.\n>\n> 2.  Compile your Elm code to JavaScript with `elm make --output=elm.js` and\n>     then make your own HTML file that loads `elm.js` and the CSS file you want.\n>     With this approach, it does not matter where the CSS comes from. Write it\n>     by hand. Generate it. Whatever you want to do.\n>\n> 3.  If you need to change `<link>` tags dynamically, you can send messages\n>     out a port to do it in JavaScript.\n>\n> The bigger point here is that loading assets involves touching the `<head>`\n> as an implementation detail of browsers, but that does not mean it should be\n> the responsibility of the `view` function in Elm. So we do it differently!\n\n[elm-css]: /packages/rtfeldman/elm-css/latest/\n\n-}\ntype alias Document msg =\n    { title : String\n    , body : List (Html msg)\n    }\n\n\n\n-- APPLICATION\n\n\n{-| Create an application that manages [`Url`][url] changes.\n\n**When the application starts**, `init` gets the initial `Url`. You can show\ndifferent things depending on the `Url`!\n\n**When someone clicks a link**, like `<a href=\"/home\">Home</a>`, it always goes\nthrough `onUrlRequest`. The resulting message goes to your `update` function,\ngiving you a chance to save scroll position or persist data before changing\nthe URL yourself with [`pushUrl`][bnp] or [`load`][bnl]. More info on this in\nthe [`UrlRequest`](#UrlRequest) docs!\n\n**When the URL changes**, the new `Url` goes through `onUrlChange`. The\nresulting message goes to `update` where you can decide what to show next.\n\nApplications always use the [`Browser.Navigation`][bn] module for precise\ncontrol over `Url` changes.\n\n**More Info:** Here are some example usages of `application` programs:\n\n  - [RealWorld example app](https://github.com/rtfeldman/elm-spa-example)\n  - [Elm’s package website](https://github.com/elm/package.elm-lang.org)\n\nThese are quite advanced Elm programs, so be sure to go through [the guide][g]\nfirst to get a solid conceptual foundation before diving in! If you start\nreading a calculus book from page 314, it might seem confusing. Same here!\n\n**Note:** Can an [`element`](#element) manage the URL too? Read [this]!\n\n[g]: https://guide.elm-lang.org/\n[bn]: Browser-Navigation\n[bnp]: Browser-Navigation#pushUrl\n[bnl]: Browser-Navigation#load\n[url]: /packages/elm/url/latest/Url#Url\n[this]: https://github.com/elm/browser/blob/1.0.2/notes/navigation-in-elements.md\n\n-}\napplication :\n    { init : flags -> Url.Url -> Navigation.Key -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    , onUrlRequest : UrlRequest -> msg\n    , onUrlChange : Url.Url -> msg\n    }\n    -> Program flags model msg\napplication =\n    Elm.Kernel.Browser.application\n\n\n{-| All links in an [`application`](#application) create a `UrlRequest`. So\nwhen you click `<a href=\"/home\">Home</a>`, it does not just navigate! It\nnotifies `onUrlRequest` that the user wants to change the `Url`.\n\n\n### `Internal` vs `External`\n\nImagine we are browsing `https://example.com`. An `Internal` link would be\nlike:\n\n  - `settings#privacy`\n  - `/home`\n  - `https://example.com/home`\n  - `//example.com/home`\n\nAll of these links exist under the `https://example.com` domain. An `External`\nlink would be like:\n\n  - `https://elm-lang.org/examples`\n  - `https://other.example.com/home`\n  - `http://example.com/home`\n\nAnything that changes the domain. Notice that changing the protocol from\n`https` to `http` is considered a different domain! (And vice versa!)\n\n\n### Purpose\n\nHaving a `UrlRequest` requires a case in your `update` like this:\n\n    import Browser exposing (..)\n    import Browser.Navigation as Nav\n    import Url\n\n    type Msg\n        = ClickedLink UrlRequest\n\n    update : Msg -> Model -> ( Model, Cmd msg )\n    update msg model =\n        case msg of\n            ClickedLink urlRequest ->\n                case urlRequest of\n                    Internal url ->\n                        ( model\n                        , Nav.pushUrl model.key (Url.toString url)\n                        )\n\n                    External url ->\n                        ( model\n                        , Nav.load url\n                        )\n\nThis is useful because it gives you a chance to customize the behavior in each\ncase. Maybe on some `Internal` links you save the scroll position with\n[`Browser.Dom.getViewport`](Browser-Dom#getViewport) so you can restore it\nlater. Maybe on `External` links you persist parts of the `Model` on your\nservers before leaving. Whatever you need to do!\n\n**Note:** Knowing the scroll position is not enough to restore it! What if the\nbrowser dimensions change? The scroll position will not correlate with\n&ldquo;what was on screen&rdquo; anymore. So it may be better to remember\n&ldquo;what was on screen&rdquo; and recreate the position based on that. For\nexample, in a Wikipedia article, remember the header that they were looking at\nmost recently. [`Browser.Dom.getElement`](Browser-Dom#getElement) is designed\nfor figuring that out!\n\n-}\ntype UrlRequest\n    = Internal Url.Url\n    | External String\n", length = 151, offCol = 4, offRow = 119, offset = 2877 }) )
            , ( "element", Comment (Snippet { fptr = "module Browser exposing\n    ( sandbox\n    , element\n    , document, Document\n    , application, UrlRequest(..)\n    )\n\n{-| This module helps you set up an Elm `Program` with functions like\n[`sandbox`](#sandbox) and [`document`](#document).\n\n\n# Sandboxes\n\n@docs sandbox\n\n\n# Elements\n\n@docs element\n\n\n# Documents\n\n@docs document, Document\n\n\n# Applications\n\n@docs application, UrlRequest\n\n-}\n\nimport Browser.Navigation as Navigation\nimport Debugger.Main\nimport Dict\nimport Elm.Kernel.Browser\nimport Html exposing (Html)\nimport Url\n\n\n\n-- SANDBOX\n\n\n{-| Create a “sandboxed” program that cannot communicate with the outside\nworld.\n\nThis is great for learning the basics of [The Elm Architecture][tea]. You can\nsee sandboxes in action in the following examples:\n\n  - [Buttons](https://guide.elm-lang.org/architecture/buttons.html)\n  - [Text Fields](https://guide.elm-lang.org/architecture/text_fields.html)\n  - [Forms](https://guide.elm-lang.org/architecture/forms.html)\n\nThose are nice, but **I very highly recommend reading [this guide][guide]\nstraight through** to really learn how Elm works. Understanding the\nfundamentals actually pays off in this language!\n\n[tea]: https://guide.elm-lang.org/architecture/\n[guide]: https://guide.elm-lang.org/\n\n-}\nsandbox :\n    { init : model\n    , view : model -> Html msg\n    , update : msg -> model -> model\n    }\n    -> Program () model msg\nsandbox impl =\n    Elm.Kernel.Browser.element\n        { init = \\() -> ( impl.init, Cmd.none )\n        , view = impl.view\n        , update = \\msg model -> ( impl.update msg model, Cmd.none )\n        , subscriptions = \\_ -> Sub.none\n        }\n\n\n\n-- ELEMENT\n\n\n{-| Create an HTML element managed by Elm. The resulting elements are easy to\nembed in larger JavaScript projects, and lots of companies that use Elm\nstarted with this approach! Try it out on something small. If it works, great,\ndo more! If not, revert, no big deal.\n\nUnlike a [`sandbox`](#sandbox), an `element` can talk to the outside world in\na couple ways:\n\n  - `Cmd` &mdash; you can “command” the Elm runtime to do stuff, like HTTP.\n  - `Sub` &mdash; you can “subscribe” to event sources, like clock ticks.\n  - `flags` &mdash; JavaScript can pass in data when starting the Elm program\n  - `ports` &mdash; set up a client-server relationship with JavaScript\n\nAs you read [the guide][guide] you will run into a bunch of examples of `element`\nin [this section][fx]. You can learn more about flags and ports in [the interop\nsection][interop].\n\n[guide]: https://guide.elm-lang.org/\n[fx]: https://guide.elm-lang.org/effects/\n[interop]: https://guide.elm-lang.org/interop/\n\n-}\nelement :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Html msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\nelement =\n    Elm.Kernel.Browser.element\n\n\n\n-- DOCUMENT\n\n\n{-| Create an HTML document managed by Elm. This expands upon what `element`\ncan do in that `view` now gives you control over the `<title>` and `<body>`.\n-}\ndocument :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\ndocument =\n    Elm.Kernel.Browser.document\n\n\n{-| This data specifies the `<title>` and all of the nodes that should go in\nthe `<body>`. This means you can update the title as your application changes.\nMaybe your \"single-page app\" navigates to a \"different page\", maybe a calendar\napp shows an accurate date in the title, etc.\n\n> **Note about CSS:** This looks similar to an `<html>` document, but this is\n> not the place to manage CSS assets. If you want to work with CSS, there are\n> a couple ways:\n>\n> 1.  Packages like [`rtfeldman/elm-css`][elm-css] give all of the features\n>     of CSS without any CSS files. You can add all the styles you need in your\n>     `view` function, and there is no need to worry about class names matching.\n>\n> 2.  Compile your Elm code to JavaScript with `elm make --output=elm.js` and\n>     then make your own HTML file that loads `elm.js` and the CSS file you want.\n>     With this approach, it does not matter where the CSS comes from. Write it\n>     by hand. Generate it. Whatever you want to do.\n>\n> 3.  If you need to change `<link>` tags dynamically, you can send messages\n>     out a port to do it in JavaScript.\n>\n> The bigger point here is that loading assets involves touching the `<head>`\n> as an implementation detail of browsers, but that does not mean it should be\n> the responsibility of the `view` function in Elm. So we do it differently!\n\n[elm-css]: /packages/rtfeldman/elm-css/latest/\n\n-}\ntype alias Document msg =\n    { title : String\n    , body : List (Html msg)\n    }\n\n\n\n-- APPLICATION\n\n\n{-| Create an application that manages [`Url`][url] changes.\n\n**When the application starts**, `init` gets the initial `Url`. You can show\ndifferent things depending on the `Url`!\n\n**When someone clicks a link**, like `<a href=\"/home\">Home</a>`, it always goes\nthrough `onUrlRequest`. The resulting message goes to your `update` function,\ngiving you a chance to save scroll position or persist data before changing\nthe URL yourself with [`pushUrl`][bnp] or [`load`][bnl]. More info on this in\nthe [`UrlRequest`](#UrlRequest) docs!\n\n**When the URL changes**, the new `Url` goes through `onUrlChange`. The\nresulting message goes to `update` where you can decide what to show next.\n\nApplications always use the [`Browser.Navigation`][bn] module for precise\ncontrol over `Url` changes.\n\n**More Info:** Here are some example usages of `application` programs:\n\n  - [RealWorld example app](https://github.com/rtfeldman/elm-spa-example)\n  - [Elm’s package website](https://github.com/elm/package.elm-lang.org)\n\nThese are quite advanced Elm programs, so be sure to go through [the guide][g]\nfirst to get a solid conceptual foundation before diving in! If you start\nreading a calculus book from page 314, it might seem confusing. Same here!\n\n**Note:** Can an [`element`](#element) manage the URL too? Read [this]!\n\n[g]: https://guide.elm-lang.org/\n[bn]: Browser-Navigation\n[bnp]: Browser-Navigation#pushUrl\n[bnl]: Browser-Navigation#load\n[url]: /packages/elm/url/latest/Url#Url\n[this]: https://github.com/elm/browser/blob/1.0.2/notes/navigation-in-elements.md\n\n-}\napplication :\n    { init : flags -> Url.Url -> Navigation.Key -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    , onUrlRequest : UrlRequest -> msg\n    , onUrlChange : Url.Url -> msg\n    }\n    -> Program flags model msg\napplication =\n    Elm.Kernel.Browser.application\n\n\n{-| All links in an [`application`](#application) create a `UrlRequest`. So\nwhen you click `<a href=\"/home\">Home</a>`, it does not just navigate! It\nnotifies `onUrlRequest` that the user wants to change the `Url`.\n\n\n### `Internal` vs `External`\n\nImagine we are browsing `https://example.com`. An `Internal` link would be\nlike:\n\n  - `settings#privacy`\n  - `/home`\n  - `https://example.com/home`\n  - `//example.com/home`\n\nAll of these links exist under the `https://example.com` domain. An `External`\nlink would be like:\n\n  - `https://elm-lang.org/examples`\n  - `https://other.example.com/home`\n  - `http://example.com/home`\n\nAnything that changes the domain. Notice that changing the protocol from\n`https` to `http` is considered a different domain! (And vice versa!)\n\n\n### Purpose\n\nHaving a `UrlRequest` requires a case in your `update` like this:\n\n    import Browser exposing (..)\n    import Browser.Navigation as Nav\n    import Url\n\n    type Msg\n        = ClickedLink UrlRequest\n\n    update : Msg -> Model -> ( Model, Cmd msg )\n    update msg model =\n        case msg of\n            ClickedLink urlRequest ->\n                case urlRequest of\n                    Internal url ->\n                        ( model\n                        , Nav.pushUrl model.key (Url.toString url)\n                        )\n\n                    External url ->\n                        ( model\n                        , Nav.load url\n                        )\n\nThis is useful because it gives you a chance to customize the behavior in each\ncase. Maybe on some `Internal` links you save the scroll position with\n[`Browser.Dom.getViewport`](Browser-Dom#getViewport) so you can restore it\nlater. Maybe on `External` links you persist parts of the `Model` on your\nservers before leaving. Whatever you need to do!\n\n**Note:** Knowing the scroll position is not enough to restore it! What if the\nbrowser dimensions change? The scroll position will not correlate with\n&ldquo;what was on screen&rdquo; anymore. So it may be better to remember\n&ldquo;what was on screen&rdquo; and recreate the position based on that. For\nexample, in a Wikipedia article, remember the header that they were looking at\nmost recently. [`Browser.Dom.getElement`](Browser-Dom#getElement) is designed\nfor figuring that out!\n\n-}\ntype UrlRequest\n    = Internal Url.Url\n    | External String\n", length = 969, offCol = 4, offRow = 82, offset = 1636 }) )
            , ( "sandbox", Comment (Snippet { fptr = "module Browser exposing\n    ( sandbox\n    , element\n    , document, Document\n    , application, UrlRequest(..)\n    )\n\n{-| This module helps you set up an Elm `Program` with functions like\n[`sandbox`](#sandbox) and [`document`](#document).\n\n\n# Sandboxes\n\n@docs sandbox\n\n\n# Elements\n\n@docs element\n\n\n# Documents\n\n@docs document, Document\n\n\n# Applications\n\n@docs application, UrlRequest\n\n-}\n\nimport Browser.Navigation as Navigation\nimport Debugger.Main\nimport Dict\nimport Elm.Kernel.Browser\nimport Html exposing (Html)\nimport Url\n\n\n\n-- SANDBOX\n\n\n{-| Create a “sandboxed” program that cannot communicate with the outside\nworld.\n\nThis is great for learning the basics of [The Elm Architecture][tea]. You can\nsee sandboxes in action in the following examples:\n\n  - [Buttons](https://guide.elm-lang.org/architecture/buttons.html)\n  - [Text Fields](https://guide.elm-lang.org/architecture/text_fields.html)\n  - [Forms](https://guide.elm-lang.org/architecture/forms.html)\n\nThose are nice, but **I very highly recommend reading [this guide][guide]\nstraight through** to really learn how Elm works. Understanding the\nfundamentals actually pays off in this language!\n\n[tea]: https://guide.elm-lang.org/architecture/\n[guide]: https://guide.elm-lang.org/\n\n-}\nsandbox :\n    { init : model\n    , view : model -> Html msg\n    , update : msg -> model -> model\n    }\n    -> Program () model msg\nsandbox impl =\n    Elm.Kernel.Browser.element\n        { init = \\() -> ( impl.init, Cmd.none )\n        , view = impl.view\n        , update = \\msg model -> ( impl.update msg model, Cmd.none )\n        , subscriptions = \\_ -> Sub.none\n        }\n\n\n\n-- ELEMENT\n\n\n{-| Create an HTML element managed by Elm. The resulting elements are easy to\nembed in larger JavaScript projects, and lots of companies that use Elm\nstarted with this approach! Try it out on something small. If it works, great,\ndo more! If not, revert, no big deal.\n\nUnlike a [`sandbox`](#sandbox), an `element` can talk to the outside world in\na couple ways:\n\n  - `Cmd` &mdash; you can “command” the Elm runtime to do stuff, like HTTP.\n  - `Sub` &mdash; you can “subscribe” to event sources, like clock ticks.\n  - `flags` &mdash; JavaScript can pass in data when starting the Elm program\n  - `ports` &mdash; set up a client-server relationship with JavaScript\n\nAs you read [the guide][guide] you will run into a bunch of examples of `element`\nin [this section][fx]. You can learn more about flags and ports in [the interop\nsection][interop].\n\n[guide]: https://guide.elm-lang.org/\n[fx]: https://guide.elm-lang.org/effects/\n[interop]: https://guide.elm-lang.org/interop/\n\n-}\nelement :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Html msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\nelement =\n    Elm.Kernel.Browser.element\n\n\n\n-- DOCUMENT\n\n\n{-| Create an HTML document managed by Elm. This expands upon what `element`\ncan do in that `view` now gives you control over the `<title>` and `<body>`.\n-}\ndocument :\n    { init : flags -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    }\n    -> Program flags model msg\ndocument =\n    Elm.Kernel.Browser.document\n\n\n{-| This data specifies the `<title>` and all of the nodes that should go in\nthe `<body>`. This means you can update the title as your application changes.\nMaybe your \"single-page app\" navigates to a \"different page\", maybe a calendar\napp shows an accurate date in the title, etc.\n\n> **Note about CSS:** This looks similar to an `<html>` document, but this is\n> not the place to manage CSS assets. If you want to work with CSS, there are\n> a couple ways:\n>\n> 1.  Packages like [`rtfeldman/elm-css`][elm-css] give all of the features\n>     of CSS without any CSS files. You can add all the styles you need in your\n>     `view` function, and there is no need to worry about class names matching.\n>\n> 2.  Compile your Elm code to JavaScript with `elm make --output=elm.js` and\n>     then make your own HTML file that loads `elm.js` and the CSS file you want.\n>     With this approach, it does not matter where the CSS comes from. Write it\n>     by hand. Generate it. Whatever you want to do.\n>\n> 3.  If you need to change `<link>` tags dynamically, you can send messages\n>     out a port to do it in JavaScript.\n>\n> The bigger point here is that loading assets involves touching the `<head>`\n> as an implementation detail of browsers, but that does not mean it should be\n> the responsibility of the `view` function in Elm. So we do it differently!\n\n[elm-css]: /packages/rtfeldman/elm-css/latest/\n\n-}\ntype alias Document msg =\n    { title : String\n    , body : List (Html msg)\n    }\n\n\n\n-- APPLICATION\n\n\n{-| Create an application that manages [`Url`][url] changes.\n\n**When the application starts**, `init` gets the initial `Url`. You can show\ndifferent things depending on the `Url`!\n\n**When someone clicks a link**, like `<a href=\"/home\">Home</a>`, it always goes\nthrough `onUrlRequest`. The resulting message goes to your `update` function,\ngiving you a chance to save scroll position or persist data before changing\nthe URL yourself with [`pushUrl`][bnp] or [`load`][bnl]. More info on this in\nthe [`UrlRequest`](#UrlRequest) docs!\n\n**When the URL changes**, the new `Url` goes through `onUrlChange`. The\nresulting message goes to `update` where you can decide what to show next.\n\nApplications always use the [`Browser.Navigation`][bn] module for precise\ncontrol over `Url` changes.\n\n**More Info:** Here are some example usages of `application` programs:\n\n  - [RealWorld example app](https://github.com/rtfeldman/elm-spa-example)\n  - [Elm’s package website](https://github.com/elm/package.elm-lang.org)\n\nThese are quite advanced Elm programs, so be sure to go through [the guide][g]\nfirst to get a solid conceptual foundation before diving in! If you start\nreading a calculus book from page 314, it might seem confusing. Same here!\n\n**Note:** Can an [`element`](#element) manage the URL too? Read [this]!\n\n[g]: https://guide.elm-lang.org/\n[bn]: Browser-Navigation\n[bnp]: Browser-Navigation#pushUrl\n[bnl]: Browser-Navigation#load\n[url]: /packages/elm/url/latest/Url#Url\n[this]: https://github.com/elm/browser/blob/1.0.2/notes/navigation-in-elements.md\n\n-}\napplication :\n    { init : flags -> Url.Url -> Navigation.Key -> ( model, Cmd msg )\n    , view : model -> Document msg\n    , update : msg -> model -> ( model, Cmd msg )\n    , subscriptions : model -> Sub msg\n    , onUrlRequest : UrlRequest -> msg\n    , onUrlChange : Url.Url -> msg\n    }\n    -> Program flags model msg\napplication =\n    Elm.Kernel.Browser.application\n\n\n{-| All links in an [`application`](#application) create a `UrlRequest`. So\nwhen you click `<a href=\"/home\">Home</a>`, it does not just navigate! It\nnotifies `onUrlRequest` that the user wants to change the `Url`.\n\n\n### `Internal` vs `External`\n\nImagine we are browsing `https://example.com`. An `Internal` link would be\nlike:\n\n  - `settings#privacy`\n  - `/home`\n  - `https://example.com/home`\n  - `//example.com/home`\n\nAll of these links exist under the `https://example.com` domain. An `External`\nlink would be like:\n\n  - `https://elm-lang.org/examples`\n  - `https://other.example.com/home`\n  - `http://example.com/home`\n\nAnything that changes the domain. Notice that changing the protocol from\n`https` to `http` is considered a different domain! (And vice versa!)\n\n\n### Purpose\n\nHaving a `UrlRequest` requires a case in your `update` like this:\n\n    import Browser exposing (..)\n    import Browser.Navigation as Nav\n    import Url\n\n    type Msg\n        = ClickedLink UrlRequest\n\n    update : Msg -> Model -> ( Model, Cmd msg )\n    update msg model =\n        case msg of\n            ClickedLink urlRequest ->\n                case urlRequest of\n                    Internal url ->\n                        ( model\n                        , Nav.pushUrl model.key (Url.toString url)\n                        )\n\n                    External url ->\n                        ( model\n                        , Nav.load url\n                        )\n\nThis is useful because it gives you a chance to customize the behavior in each\ncase. Maybe on some `Internal` links you save the scroll position with\n[`Browser.Dom.getViewport`](Browser-Dom#getViewport) so you can restore it\nlater. Maybe on `External` links you persist parts of the `Model` on your\nservers before leaving. Whatever you need to do!\n\n**Note:** Knowing the scroll position is not enough to restore it! What if the\nbrowser dimensions change? The scroll position will not correlate with\n&ldquo;what was on screen&rdquo; anymore. So it may be better to remember\n&ldquo;what was on screen&rdquo; and recreate the position based on that. For\nexample, in a Wikipedia article, remember the header that they were looking at\nmost recently. [`Browser.Dom.getElement`](Browser-Dom#getElement) is designed\nfor figuring that out!\n\n-}\ntype UrlRequest\n    = Internal Url.Url\n    | External String\n", length = 696, offCol = 4, offRow = 45, offset = 546 }) )
            ]
        )
        (Declare
            (TypedDef
                (At (Region (Position 69 1) (Position 69 8)) "sandbox")
                (D [ ( "model", () ), ( "msg", () ) ])
                [ ( At (Region (Position 69 9) (Position 69 13)) (PVar "impl")
                  , TRecord
                        (D
                            [ ( "init", FieldType 0 (TVar "model") )
                            , ( "update", FieldType 2 (TLambda (TVar "msg") (TLambda (TVar "model") (TVar "model"))) )
                            , ( "view"
                              , FieldType 1
                                    (TLambda (TVar "model")
                                        (TAlias (Canonical (Name "elm" "html") "Html")
                                            "Html"
                                            [ ( "msg", TVar "msg" )
                                            ]
                                            (Holey (TType (Canonical (Name "elm" "virtual-dom") "VirtualDom") "Node" [ TVar "msg" ]))
                                        )
                                    )
                              )
                            ]
                        )
                        Nothing
                  )
                ]
                (At (Region (Position 70 5) (Position 75 10))
                    (Call
                        (At (Region (Position 70 5) (Position 70 31)) (VarKernel "Browser" "element"))
                        [ At (Region (Position 71 9) (Position 75 10))
                            (Record
                                (D
                                    [ ( "init"
                                      , At (Region (Position 71 18) (Position 71 48))
                                            (Lambda [ At (Region (Position 71 19) (Position 71 21)) PUnit ]
                                                (At (Region (Position 71 25) (Position 71 48))
                                                    (Tuple
                                                        (At (Region (Position 71 27) (Position 71 36))
                                                            (Access
                                                                (At (Region (Position 71 27) (Position 71 31)) (VarLocal "impl"))
                                                                (At (Region (Position 71 32) (Position 71 36)) "init")
                                                            )
                                                        )
                                                        (At (Region (Position 71 38) (Position 71 46))
                                                            (VarForeign (Canonical (Name "elm" "core") "Platform.Cmd")
                                                                "none"
                                                                (Forall (D [ ( "msg", () ) ])
                                                                    (TType (Canonical (Name "elm" "core") "Platform.Cmd") "Cmd" [ TVar "msg" ])
                                                                )
                                                            )
                                                        )
                                                        Nothing
                                                    )
                                                )
                                            )
                                      )
                                    , ( "subscriptions", At (Region (Position 74 27) (Position 74 41)) (Lambda [ At (Region (Position 74 28) (Position 74 29)) PAnything ] (At (Region (Position 74 33) (Position 74 41)) (VarForeign (Canonical (Name "elm" "core") "Platform.Sub") "none" (Forall (D [ ( "msg", () ) ]) (TType (Canonical (Name "elm" "core") "Platform.Sub") "Sub" [ TVar "msg" ]))))) )
                                    , ( "update", At (Region (Position 73 20) (Position 73 69)) (Lambda [ At (Region (Position 73 21) (Position 73 24)) (PVar "msg"), At (Region (Position 73 25) (Position 73 30)) (PVar "model") ] (At (Region (Position 73 34) (Position 73 69)) (Tuple (At (Region (Position 73 36) (Position 73 57)) (Call (At (Region (Position 73 36) (Position 73 47)) (Access (At (Region (Position 73 36) (Position 73 40)) (VarLocal "impl")) (At (Region (Position 73 41) (Position 73 47)) "update"))) [ At (Region (Position 73 48) (Position 73 51)) (VarLocal "msg"), At (Region (Position 73 52) (Position 73 57)) (VarLocal "model") ])) (At (Region (Position 73 59) (Position 73 67)) (VarForeign (Canonical (Name "elm" "core") "Platform.Cmd") "none" (Forall (D [ ( "msg", () ) ]) (TType (Canonical (Name "elm" "core") "Platform.Cmd") "Cmd" [ TVar "msg" ])))) Nothing))) )
                                    , ( "view", At (Region (Position 72 18) (Position 72 27)) (Access (At (Region (Position 72 18) (Position 72 22)) (VarLocal "impl")) (At (Region (Position 72 23) (Position 72 27)) "view")) )
                                    ]
                                )
                            )
                        ]
                    )
                )
                (TType (Canonical (Name "elm" "core") "Platform") "Program" [ TUnit, TVar "model", TVar "msg" ])
            )
            (Declare (TypedDef (At (Region (Position 111 1) (Position 111 8)) "element") (D [ ( "flags", () ), ( "model", () ), ( "msg", () ) ]) [] (At (Region (Position 112 5) (Position 112 31)) (VarKernel "Browser" "element")) (TLambda (TRecord (D [ ( "init", FieldType 0 (TLambda (TVar "flags") (TTuple (TVar "model") (TType (Canonical (Name "elm" "core") "Platform.Cmd") "Cmd" [ TVar "msg" ]) Nothing)) ), ( "subscriptions", FieldType 3 (TLambda (TVar "model") (TType (Canonical (Name "elm" "core") "Platform.Sub") "Sub" [ TVar "msg" ])) ), ( "update", FieldType 2 (TLambda (TVar "msg") (TLambda (TVar "model") (TTuple (TVar "model") (TType (Canonical (Name "elm" "core") "Platform.Cmd") "Cmd" [ TVar "msg" ]) Nothing))) ), ( "view", FieldType 1 (TLambda (TVar "model") (TAlias (Canonical (Name "elm" "html") "Html") "Html" [ ( "msg", TVar "msg" ) ] (Holey (TType (Canonical (Name "elm" "virtual-dom") "VirtualDom") "Node" [ TVar "msg" ])))) ) ]) Nothing) (TType (Canonical (Name "elm" "core") "Platform") "Program" [ TVar "flags", TVar "model", TVar "msg" ]))) (Declare (TypedDef (At (Region (Position 129 1) (Position 129 9)) "document") (D [ ( "flags", () ), ( "model", () ), ( "msg", () ) ]) [] (At (Region (Position 130 5) (Position 130 32)) (VarKernel "Browser" "document")) (TLambda (TRecord (D [ ( "init", FieldType 0 (TLambda (TVar "flags") (TTuple (TVar "model") (TType (Canonical (Name "elm" "core") "Platform.Cmd") "Cmd" [ TVar "msg" ]) Nothing)) ), ( "subscriptions", FieldType 3 (TLambda (TVar "model") (TType (Canonical (Name "elm" "core") "Platform.Sub") "Sub" [ TVar "msg" ])) ), ( "update", FieldType 2 (TLambda (TVar "msg") (TLambda (TVar "model") (TTuple (TVar "model") (TType (Canonical (Name "elm" "core") "Platform.Cmd") "Cmd" [ TVar "msg" ]) Nothing))) ), ( "view", FieldType 1 (TLambda (TVar "model") (TAlias (Canonical (Name "elm" "browser") "Browser") "Document" [ ( "msg", TVar "msg" ) ] (Holey (TRecord (D [ ( "body", FieldType 1 (TType (Canonical (Name "elm" "core") "List") "List" [ TAlias (Canonical (Name "elm" "html") "Html") "Html" [ ( "msg", TVar "msg" ) ] (Holey (TType (Canonical (Name "elm" "virtual-dom") "VirtualDom") "Node" [ TVar "msg" ])) ]) ), ( "title", FieldType 0 (TType (Canonical (Name "elm" "core") "String") "String" []) ) ]) Nothing)))) ) ]) Nothing) (TType (Canonical (Name "elm" "core") "Platform") "Program" [ TVar "flags", TVar "model", TVar "msg" ]))) (Declare (TypedDef (At (Region (Position 216 1) (Position 216 12)) "application") (D [ ( "flags", () ), ( "model", () ), ( "msg", () ) ]) [] (At (Region (Position 217 5) (Position 217 35)) (VarKernel "Browser" "application")) (TLambda (TRecord (D [ ( "init", FieldType 0 (TLambda (TVar "flags") (TLambda (TAlias (Canonical (Name "elm" "url") "Url") "Url" [] (Holey (TRecord (D [ ( "fragment", FieldType 5 (TType (Canonical (Name "elm" "core") "Maybe") "Maybe" [ TType (Canonical (Name "elm" "core") "String") "String" [] ]) ), ( "host", FieldType 1 (TType (Canonical (Name "elm" "core") "String") "String" []) ), ( "path", FieldType 3 (TType (Canonical (Name "elm" "core") "String") "String" []) ), ( "port_", FieldType 2 (TType (Canonical (Name "elm" "core") "Maybe") "Maybe" [ TType (Canonical (Name "elm" "core") "Basics") "Int" [] ]) ), ( "protocol", FieldType 0 (TType (Canonical (Name "elm" "url") "Url") "Protocol" []) ), ( "query", FieldType 4 (TType (Canonical (Name "elm" "core") "Maybe") "Maybe" [ TType (Canonical (Name "elm" "core") "String") "String" [] ]) ) ]) Nothing))) (TLambda (TType (Canonical (Name "elm" "browser") "Browser.Navigation") "Key" []) (TTuple (TVar "model") (TType (Canonical (Name "elm" "core") "Platform.Cmd") "Cmd" [ TVar "msg" ]) Nothing)))) ), ( "onUrlChange", FieldType 5 (TLambda (TAlias (Canonical (Name "elm" "url") "Url") "Url" [] (Holey (TRecord (D [ ( "fragment", FieldType 5 (TType (Canonical (Name "elm" "core") "Maybe") "Maybe" [ TType (Canonical (Name "elm" "core") "String") "String" [] ]) ), ( "host", FieldType 1 (TType (Canonical (Name "elm" "core") "String") "String" []) ), ( "path", FieldType 3 (TType (Canonical (Name "elm" "core") "String") "String" []) ), ( "port_", FieldType 2 (TType (Canonical (Name "elm" "core") "Maybe") "Maybe" [ TType (Canonical (Name "elm" "core") "Basics") "Int" [] ]) ), ( "protocol", FieldType 0 (TType (Canonical (Name "elm" "url") "Url") "Protocol" []) ), ( "query", FieldType 4 (TType (Canonical (Name "elm" "core") "Maybe") "Maybe" [ TType (Canonical (Name "elm" "core") "String") "String" [] ]) ) ]) Nothing))) (TVar "msg")) ), ( "onUrlRequest", FieldType 4 (TLambda (TType (Canonical (Name "elm" "browser") "Browser") "UrlRequest" []) (TVar "msg")) ), ( "subscriptions", FieldType 3 (TLambda (TVar "model") (TType (Canonical (Name "elm" "core") "Platform.Sub") "Sub" [ TVar "msg" ])) ), ( "update", FieldType 2 (TLambda (TVar "msg") (TLambda (TVar "model") (TTuple (TVar "model") (TType (Canonical (Name "elm" "core") "Platform.Cmd") "Cmd" [ TVar "msg" ]) Nothing))) ), ( "view", FieldType 1 (TLambda (TVar "model") (TAlias (Canonical (Name "elm" "browser") "Browser") "Document" [ ( "msg", TVar "msg" ) ] (Holey (TRecord (D [ ( "body", FieldType 1 (TType (Canonical (Name "elm" "core") "List") "List" [ TAlias (Canonical (Name "elm" "html") "Html") "Html" [ ( "msg", TVar "msg" ) ] (Holey (TType (Canonical (Name "elm" "virtual-dom") "VirtualDom") "Node" [ TVar "msg" ])) ]) ), ( "title", FieldType 0 (TType (Canonical (Name "elm" "core") "String") "String" []) ) ]) Nothing)))) ) ]) Nothing) (TType (Canonical (Name "elm" "core") "Platform") "Program" [ TVar "flags", TVar "model", TVar "msg" ]))) SaveTheEnvironment)))
        )
        (D
            [ ( "UrlRequest"
              , Union []
                    [ Ctor "Internal"
                        (ZeroBased 0)
                        1
                        [ TAlias (Canonical (Name "elm" "url") "Url")
                            "Url"
                            []
                            (Holey (TRecord (D [ ( "fragment", FieldType 5 (TType (Canonical (Name "elm" "core") "Maybe") "Maybe" [ TType (Canonical (Name "elm" "core") "String") "String" [] ]) ), ( "host", FieldType 1 (TType (Canonical (Name "elm" "core") "String") "String" []) ), ( "path", FieldType 3 (TType (Canonical (Name "elm" "core") "String") "String" []) ), ( "port_", FieldType 2 (TType (Canonical (Name "elm" "core") "Maybe") "Maybe" [ TType (Canonical (Name "elm" "core") "Basics") "Int" [] ]) ), ( "protocol", FieldType 0 (TType (Canonical (Name "elm" "url") "Url") "Protocol" []) ), ( "query", FieldType 4 (TType (Canonical (Name "elm" "core") "Maybe") "Maybe" [ TType (Canonical (Name "elm" "core") "String") "String" [] ]) ) ]) Nothing))
                        ]
                    , Ctor "External"
                        (ZeroBased 1)
                        1
                        [ TType (Canonical (Name "elm" "core") "String") "String" [] ]
                    ]
                    2
                    Normal
              )
            ]
        )
        (D
            [ ( "Document"
              , Alias [ "msg" ]
                    (TRecord
                        (D
                            [ ( "body"
                              , FieldType 1
                                    (TType (Canonical (Name "elm" "core") "List")
                                        "List"
                                        [ TAlias (Canonical (Name "elm" "html") "Html")
                                            "Html"
                                            [ ( "msg", TVar "msg" ) ]
                                            (Holey (TType (Canonical (Name "elm" "virtual-dom") "VirtualDom") "Node" [ TVar "msg" ]))
                                        ]
                                    )
                              )
                            , ( "title", FieldType 0 (TType (Canonical (Name "elm" "core") "String") "String" []) )
                            ]
                        )
                        Nothing
                    )
              )
            ]
        )
        (D [])
